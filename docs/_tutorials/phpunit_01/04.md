---
title: "PHPUnit - TP 1"
subtitle: "Assurer les bonnes pratiques du projet"
permalink: /phpunit/tp/1/page/4
---

Pour r√©pondre √† des probl√©matiques de projet, les "tech" vont concevoir des solutions/r√©ponses et les mettre en place
au sein de leur projet. Ces nouvelles pratiques mises en place dans le projet vont √™tre partag√©es avec les autres et
avec les futurs intervenants, notamment par le biais d'une documentation.

Cependant, il est compliqu√© de s'assurer que chacun respecte ces pratiques ou les applique correctement.

On peut alors √©tendre l'utilisation des tests unitaires cod√©s pour v√©rifier que certaines pratiques sont bien mises
en place et continuent √† √™tre utilis√©es au fil de l'√©volution du projet.

# 1. Objectifs d'un DTO

Comme vu pr√©c√©demment, un DTO est une classe qui doit r√©pondre √† ces contraintes :

* La seule utilisation de l'objet est de r√©cup√©rer les donn√©es qu'il transporte.
* Ces donn√©es doivent √™tre immuables, c'est-√†-dire en lecture seule.
* L'objet ne doit pas mettre √† disposition des m√©thodes publiques.
  <br>Si le besoin est de transformer les donn√©es, il faut utiliser un autre type d'objet, comme un `DataTransformer`.

Avec les √©volutions de PHP, il est possible de r√©pondre √† ces contraintes par le biais des √©l√©ments suivants :

* Les propri√©t√©s doivent utiliser le mot-clef `readonly`, ce qui les rend immuables ; elles ne peuvent √™tre modifi√©es
  qu'√† l'instanciation de l'objet (dans le constructeur).
* Les propri√©t√©s doivent √™tre publiques, ce qui permet de les r√©cup√©rer sans avoir √† utiliser de m√©thode.

Une fois ces r√®gles d√©finies, on peut s'assurer de leur mise en place √† travers des tests unitaires et les
`ReflectionClass` de PHP, qui permettent de r√©cup√©rer des informations sur une classe. C'est gr√¢ce √† ces informations
que l'on va pouvoir mettre en place des tests qui v√©rifient que les r√®gles de d√©veloppement sont bien respect√©es.

[Lien vers la documentation PHP des `ReflectionClass`](https://www.php.net/manual/fr/class.reflectionclass.php).

## 1.1 Tester les propri√©t√©s

Vous allez compl√©ter vos tests unitaires sur le `MediaDto` afin de v√©rifier que toutes les propri√©t√©s de la classe sont
d√©finies comme `readonly` et `public`.

{% 
  include templates/components/_hint.liquid
  content="Jetez un ≈ìil √† la m√©thode `ReflectionClass::getProperties()` et √† la classe `ReflectionProperty`..."
%}

Ce test devrait alors vous ajouter `4 x 2` assertions (4 propri√©t√©s, 2 assertions diff√©rentes).

Rajoutez maintenant une propri√©t√© priv√©e dans le DTO et une propri√©t√© publique, mais pas en lecture seule (il faudra
faire quelques ajustements sur la classe pour pouvoir le faire).

Profitez-en pour supprimer vos tests sur le constructeur, qui ne sont plus utiles.

V√©rifiez que phpunit remonte **deux** failures. S'il n'y en a qu'une, vous devriez s√ªrement utiliser un Data Provider
plut√¥t qu'une boucle `foreach` dans votre test...

Faites un *revert* de vos modifications sur la classe `MediaDto` afin que vos tests soient √† nouveau au vert.

## 1.2 Tester les m√©thodes

Vous allez compl√©ter vos tests unitaires sur le `MediaDto` afin de v√©rifier que la classe ne met √† disposition aucune
m√©thode d√©finies comme `public`.

{% 
  include templates/components/_hint.liquid
  content="Jetez un ≈ìil √† la m√©thode `ReflectionClass::getMethods()` et √† la classe `ReflectionMethod`..."
%}

> ‚ö†Ô∏è Le constructeur est une m√©thode d√©finie comme `public`, elle doit √™tre autoris√©e dans ce test.
> <br>Lorsque vous √™tes dans ce cas de figure, utilisez l'instruction `$this->addToAssertionCount(count: 1);` afin
> d'indiquer qu'une assertion a √©t√© faite.

Ce test devrait alors vous ajouter une assertion suppl√©mentaire.

Rajoutez maintenant trois m√©thodes dans votre DTO pour `public`, `protected` et `private`. V√©rifiez que phpunit rajoute
trois assertions suppl√©mentaires dont une en √©chec.

Faites un *revert* de vos modifications sur la classe `MediaDto` afin que vos tests soient √† nouveau au vert.

## 1.3. Tester **tous** les DTOs

Vous avez √©crit des tests pour une classe `DTO`, ce qui signifie qu'il faudrait faire la m√™me chose pour toutes les
classes `DTO` du projet. Par ailleurs, vous devez vous assurer que chaque nouveau `DTO` aura des tests unitaires.

Cela semble √™tre une t√¢che r√©p√©titive et fastidieuse, qui a de fortes probabilit√©s d'√™tre oubli√©e au fil du temps.

Vous allez donc cr√©er un test applicable √† l'ensemble des classes `DTO` du projet, c'est-√†-dire toutes les classes
correspondant au pattern `*Dto.php` et incluses dans le namespaces `TroisOlen\PhpunitTp\Model` (ou dans le dossier
`src/Model/`).

Vous devriez alors avoir trois tests pour les m√©thodes (correspondant au constructeur des trois DTOs existants) et
neuf tests (soit dix-huit assertions) pour les propri√©t√©s (trois pour le `AnswerDto`, deux pour le `QuoteDto` et
quatre pour le `MediaDto`).

Une fois ces tests √©crits et valides, vous pouvez supprimer la classe de test sur `MediaDto`, qui a √©t√© remplac√©e par
vos nouveaux tests.

# 2. Objectifs d'un `AbstractStaticFactory`

Le projet met √† dispositions des classes `Factory` en se basant sur le *design pattern* √©ponyme.

Une "factory" est une classe permettant d'instancier un object d'une classe pr√©cise, en fonction de param√®tres donn√©s.
L'objectif de cette classe est de centraliser la cr√©ation d'objects complexes afin de ne pas avoir besoin de dupliquer
du code ou √† utiliser des constructeurs statiques directement dans la classe concern√©e.

Ainsi une classe `FooFactory` permettra d'instancier des objects de la classe `Foo`.

Les *factories* peuvent √™tre des services (c'est-√†-dire des classes instanci√©es une seule fois et inject√©es en tant
que d√©pendances dans d'autres classes) ou des classes "statiques" (c'est-√†-dire des classes qui ne sont pas instanci√©es
et dont les m√©thodes sont appel√©es directement).

C'est justement ce dernier cas qui est mis en pratique dans le projet √† travers la classe abstraite
`AbstractStaticFactory` qui s'assure que les classes qui en h√©ritent ne puissent pas √™tre instanci√©es en rendant le
constructeur `private` (non appelable en dehors de la classe, ou dans les classes filles), `final` (non surchargeable
dans les classes filles) et levant une exception.

Selon les m√™mes concepts que pr√©c√©demment, vous allez utiliser les tests unitaires pour v√©rifier que les classes
`Factory` h√©ritant de la `AbstractStaticFactory` n'aient aucune m√©thode `public` qui ne soit pas `static` ET un
constructeur `private` et `final`.

## 2.1 Tester les m√©thodes

Vous allez √©crire un test pour la classe `MediaTypeEnumFactory` qui v√©rifie les conditions suivantes sur l'ensemble de
ses m√©thodes :
- Le constructeur est `private` et `final`.
- Les m√©thodes `public` √† disposition sont toutes `static` et qu'il y en ait au moins une.

Une fois ces tests pr√™ts, v√©rifiez le rapport de PHPUnit et rajoutez une m√©thode `public` non `static`, une m√©thode
`protected` et une m√©thode `private`. Vous devriez alors avoir un test en "FAILED".

Faites un revert des modifications de la classe `MediaTypeEnumFactory` pour que vos tests passent en "OK".

> ‚ÑπÔ∏è Il ne sera pas possible de tester la surcharge du constructeur ou l'appel au constructeur dans la classe factory
> puisque les mots-clefs `final` et `private` l√®vent une erreur PHP √† l'ex√©cution.

## 2.2 Tester **toutes** les *factories* h√©ritant de `AbstractStaticFactory`

Comme pr√©c√©demment avec les DTO, les tests que vous venez d'√©crire ne s'appliquent qu'√† une seule *factory* or, nous
aimerions qu'il y ait que ces tests soient communs √† toutes les *factories* concern√©es.

Faites en sorte de r√©cup√©rer toutes les classes `*Factory` pr√©sentent dans le namespace `TroisOlen\Phpunit\Factory`
(ou dans le dossier `src/Factory/`) **et** h√©ritant de la classe `AbstractStaticFactory`, puis de r√©aliser les tests
que vous avez d√©finis.

Une fois ces tests √©crits et valides, vous pouvez supprimer ceux de la classe `MediaTypeEnumFactory`. Faites attention
√† ne pas supprimer les tests sur la m√©thode `getFromConverter()` qui sont toujours utiles et pertinents.

# Retour aux concepts de base

Avec la "R√©flexion", vous obtenez des tests plus pouss√©s et pouvant m√™me r√©pondre √† des probl√©matiques particuli√®res,
voire bloquantes dans certains cas. Il s'agit quand m√™me d'une utilisation avanc√©e de PHP et de PHPUnit et vous allez
retrouver quelques concepts de base, √† savoir les "doublures" (üá¨üáß *doubles*).
