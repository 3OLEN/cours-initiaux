---
title: "PHPUnit - TP 1"
subtitle: "Utiliser des doublures"
permalink: /phpunit/tp/1/page/5
---

Dans la programmation objet, il arrive fr√©quemment qu'une classe soit d√©pendante d'une autre :

* Soit cette autre classe est un composant, c'est-√†-dire qu'elle appartient √† la premi√®re.
  <br>G√©n√©ralement, cette autre classe est d√©finie en tant que propri√©t√© de la premi√®re et affect√©e dans le 
  constructeur.
* Soit cette autre classe est une d√©pendance, c'est-√†-dire qu'elle est fournie √† la premi√®re dans un cas d'utilisation
  pr√©cis.
  <br>G√©n√©ralement, cette autre classe est d√©finie en tant que param√®tre de la m√©thode dans laquelle la premi√®re
  n√©cessite l'utilisation de cette classe. Elle peut aussi √™tre inject√©e en tant que d√©pendance.

Dans un contexte de tests, cela signifie que pour tester la premi√®re classe, il faut cr√©er les classes dont elle
d√©pend. Sachant que ces classes peuvent, √©ventuellement, aussi d√©pendre d'autres classes, il peut arriver qu'il soit
n√©cessaire d'instancier des dizaines de classes pour en tester une seule, ce qui n'est pas agr√©able pour √©crire
des tests.

Par ailleurs, ces autres classes peuvent requ√©rir des relations avec des composants externes (BDD, fichiers, API) qui
ne sont pas forc√©ment accessibles dans un environnement de test, ou ces autres classes peuvent ne pas √™tre
totalement pr√™tes et fonctionnelles.

Au sein des tests unitaires, on n'a pas besoin de s'assurer que les classes annexes soient fonctionnelles puisqu'on ne
veut tester qu'une partie de notre classe.

Comme dans le monde du showbiz, on peut utiliser des "doublures" qui portent les noms de `Stubs` ou de `Mocks`.

Ces composants ont pour objectif de simuler le comportement d'une classe et de ses m√©thodes afin de pouvoir tester
unitairement sans √™tre d√©pendant de l'impl√©mentation d'autres classes ou de composants externes.

Ces composants peuvent alors simuler plusieurs choses :

* L'instanciation d'une classe, ou l'impl√©mentation d'une interface (ou de plusieurs en m√™me temps).
* Le retour d'une m√©thode.
* Et dans le cas des `Mocks`, le nombre d'appels √† certaines m√©thodes ou encore les param√®tres utilis√©s.

En revanche, il y a des limitations √† l'utilisation des "doublures" : les classes `final` ne peuvent pas avoir de
doublure et les m√©thodes `private`, `static` ou `final` ne peuvent pas non plus √™tre simul√©es par une doublure.

# 0. Modifications du code source

Votre version actuelle du code source de l'application ne vous permet pas de d√©finir des tests de "doublures" assez
d'une mani√®re simple et accessible, c'est pourquoi vous allez r√©cup√©rer une autre version de l'application.

1. Assurez-vous d'avoir commit√© votre travail en local.
2. R√©cup√©rez le commit `a3a7817` du repository template `https://github.com/3OLEN/phpunit-tp`.
   <br>Je vous laisse faire la petite recherche sur Internet pour trouver la solution.
3. V√©rifiez que vous avez bien des fichiers dans `Entity/` ou dans `Repository/`.
4. V√©rifiez que vos tests passent toujours.

Maintenant que votre code source est √† niveau, vous allez pouvoir faire du test de doublure.

# 1. Validation de l'entit√©

Les modifications r√©cup√©r√©es concernent les pr√©mices de l'int√©gration d'une base de donn√©es, qui de toute fa√ßon n'a pas
d'int√©r√™t dans des tests unitaires (il est tout √† fait possible de d√©finir des tests d'int√©gration cod√©s avec PHPUnit).
N√©anmoins, les services et les interfaces sont d√©finis et suffisamment pr√™ts pour faire du test unitaire.

Un nouveau service a √©t√© d√©velopp√© : `QuoteEntityValidator`, dont l'objectif est de valider qu'un objet de l'entit√©
`Quote` r√©pond √† des r√®gles de validation :

1. Il est persist√© et pr√©sent en base.
2. Ses champs sont valoris√©s.

L'id√©e, c'est de s'assurer que l'objet que l'on manipule est bien r√©el et qu'il va pouvoir √™tre utilis√© notamment par la
`QuoteRiddleFactory` afin de le transformer en `QuoteDto` pour qu'il soit utilis√© dans le reste de l'application.

Cette classe est parfaite pour utiliser les *Stubs* (üá´üá∑ bouchon) et les *Mocks* (üá´üá∑ simulacre).

## 1.1. ü§î R√©flexions sur le test de la validation

Ce service de validation met √† disposition la m√©thode `assertValidity()` afin de r√©aliser les diverses v√©rifications. 
Pour que l'action soit men√©e √† bien, le service a besoin de plusieurs √©l√©ments :

* Un objet de l'entit√© `Quote`, bien entendu, fourni en param√®tre.
* Une d√©pendance vers le *repository* de l'entit√© `Quote`, par le biais de son interface.
  <br>Une interface, qui d'ailleurs, n'existe pas encore, mais gr√¢ce aux "doublures" ce n'est pas un probl√®me.
* Une d√©pendance vers un autre service de validation, en l'occurrence pour l'entit√© `Media` (composite de l'entit√©
  `Quote` du fait d'un lien de clef √©trang√®re en BDD).

Ces classes devront √™tre simul√©es pour plusieurs raisons :

* Il est plus simple de simuler l'instance d'une classe au lieu de l'instancier √† la main, surtout si cette classe a
  besoin de divers √©l√©ments ou d'une certaine logique.
* Les impl√©mentations des diverses interfaces doivent √™tre simul√©es ; leur fonctionnement effectif ou non ne doit pas
  avoir d'incidence sur les tests unitaires (dans les tests d'int√©gration, fonctionnels ou de bout-en-bout, en
  revanche, oui).
  <br>Par ailleurs, cela permet de tester la classe alors m√™me qu'une interface ne poss√®de pas encore d'impl√©mentation
  effective.
* Certains comportements ne sont possibles que par rapport √† des retours sp√©cifiques des m√©thodes des classes utilis√©es.
  Il est donc int√©ressant de pouvoir manipuler ces retours.

Vous allez avoir besoin des `Stubs`.

## 1.2. ‚úÖ Tester le cas usuel (valide)

Au sein d'une classe de test (vous testez la m√©thode `assertValidity()` de la classe `QuoteEntityValidator`), vous allez
devoir cr√©er une instance de la classe, en utilisant des *stubs* (un petit coup d'≈ìil √† la documentation) pour
remplacer les deux param√®tres `$quoteRepository` et `$movieEntityValidator`.

Puis, vous allez fournir le *stub* de l'entit√© `Quote` √† la m√©thode.

### 1.2.1. Ex√©cuter le test

Une fois que votre appel est pr√™t, vous allez pouvoir ex√©cuter le test.

Vous devriez avoir un rejet de la part du validateur par le biais d'une exception. Ce peut √™tre pour deux raisons :

1. La m√©thode `Quote::getId()` retourne la valeur `null`.
2. La m√©thode `QuoteRepositoryInterface::exist()` retourne la valeur `false`.

Un *stub* n'ex√©cute pas le code de ses m√©thodes, mais il retourne une valeur par d√©faut (d√©finie par PHPUnit) si la
m√©thode a un type de retour.

N'h√©sitez pas √† utiliser des `var_dump()` pour comprendre un peu ce qu'il se trame.

### 1.2.2. D√©finir un retour aux m√©thodes du *stub*

Vous allez devoir d√©finir le retour des deux m√©thodes indiqu√©es un peu plus haut afin de vous positionner dans un cas
qui pourrait fonctionner :

```php
$doubledQuote = $this->createStub(Quote::class);
$doubledQuote
    ->method('getId')
    ->willReturn(1);
```

et 

```php
$mockedQuoteRepository = $this->createStub(QuoteRepositoryInterface::class);
$mockedQuoteRepository
    ->method('exist')
    ->willReturn(true);
```

De cette mani√®re, vous devriez pouvoir faire passer le premier rejet de la m√©thode de v√©rification.

> L'entit√© `Quote` d√©finit des mutateurs (*setters*), vous pourriez alors d√©finir la valeur de la propri√©t√© `$id` de
> votre *stub* sans pour autant configurer la m√©thode `getId()` pour retourner un r√©sultat. Si vous testez ce code :
> ```php
> $doubledQuote = $this->createStub(Quote::class);
> $doubledQuote->setId(1);
> ```
> Au lieu de celui indiqu√© plus haut, vous verrez que la valeur de `$id` reste √† `null`. La raison est √©crite un peu
> plus haut.

### 1.2.3. Jusqu'au succ√®s, ou presque...

En ajoutant d'autres configurations de retour de m√©thode pour vos trois *stubs*, vous devriez pouvoir arriver jusqu'√†
la r√©ussite de votre test.

Si vous n'avez pas r√©alis√© d'assertion dans votre test, il devrait √™tre marqu√© en "risky", parce qu'il ne r√©alise
aucune assertion. On pourrait rajouter une assertion apr√®s l'appel √† la m√©thode, mais pour tester quoi ?

C'est l√† qu'une des particularit√©s des `Mocks` entre en jeu, puisque vous allez pouvoir tester que des appels √† des
m√©thodes de votre "doublure" (en l'occurrence de votre "simulacre") ont √©t√© faits et mettre le nombre de fois.

Vous allez donc vous assurer que la m√©thode `exist()` du *repository* a √©t√© appel√©e ET que la m√©thode `assertValidity()`
du service `MovieEntityValidator` a √©t√© appel√©e √©galement :

```php
$mockedQuoteRepository = $this->createMock(QuoteRepositoryInterface::class);
$mockedQuoteRepository
    ->expects(static::once())
    ->method('exist')
    ->willReturn(true);

$mockedMovieValidator = $this->createMock(MovieEntityValidator::class);
$mockedMovieValidator
    ->expects(static::once())
    ->method('assertValidity');
```

Ces deux services-l√† vont alors devenir des `Mocks` plut√¥t que les `Stubs` que l'on avait d√©finis plus t√¥t.

Bien s√ªr, vous gardez le *stub* de l'entit√© `Quote`.

Ces instructions *expect* vont agir comme des assertions et si la condition indiqu√©e n'est pas respect√©e, l'assertion
sera consid√©r√©e en erreur. Vous pouvez d√©finir qu'une m√©thode ne sera jamais appel√©e, ou une seule fois, ou 7 fois, ou
au moins 12 fois, ou moins de 3 fois, etc.

En sp√©cifiant ces deux instructions, on veut s'assurer que pour la validation de l'entit√©, le service a bien fait appel
√† ces deux m√©thodes exactement une fois chacun.

En ex√©cutant le test, vous devriez avoir deux assertions suppl√©mentaires et tout en ¬´ OK ¬ª.

## 1.3. ‚ùå Tester les cas de rejet

Lors d'un rejet, la m√©thode l√®ve une exception : `InvalidLoadedEntityException`. En vous basant sur ce que vous avez
fait plus haut, vous allez vous assurer que les cinq cas suivants sont en rejet :

1. `Quote::$id` est √† `null`.
2. `QuoteRepositoryInterface::exist()` retourne `false`.
3. `Quote::$value` est √† `null`.
4. `Quote::$movie` est √† `null`.
5. `MovieEntityValidator::assertValidity()` l√®ve une `InvalidLoadedEntityException`.
   * Oui, un `Mock` peut configurer une m√©thode √† lever une exception.
   * Vous v√©rifiez √©galement que l'exception lev√©e a pour `$previous` une instance de `InvalidLoadedEntityException`.

Vous utiliserez un `DataProvider`, ce sera plus simple et √©volutif si d'autres cas doivent √™tre test√©s plus tard.

### Assertion des appels

Am√©liorer ces tests de rejet en d√©finissant si les m√©thodes `QuoteRepositoryInterface::exist()` et
`MovieEntityValidator::assertValidity()` sont appel√©es ou non, selon les cas.

√âtudiez bien le code de la m√©thode de test pour vous en assurer.

# Encha√Æner les challenges

Vous avez pu manipuler un peu les "doublures" (dans le cadre des tests, pas dans le domaine du cin√©ma attention !) afin
de d√©finir des tests unitaires plus pouss√©s sans pour autant vous bloquer parce qu'une impl√©mentation est manquante ou
parce que vous devez instancier pl√©thore de classes pour simplement v√©rifier un petit cas particulier.

Et si on poussait le vice un peu plus loin ?
