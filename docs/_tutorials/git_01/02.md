---
title: "Git - TP 1"
subtitle: "Contenu basique d'un projet Git"
permalink: /git/tp/1/page/2
---

> Dans les Ã©tapes suivantes, vous continuerez Ã  travailler en pair-programming.

# 1. .gitignore

Durant le TP, certains scripts de vÃ©rification seront mis Ã  disposition. Il ne faut surtout pas les commiter dans le 
repository. Pour cela, il faut les ignorer.

## ğŸ“‹ï¸ Instructions

1. CrÃ©ez la branche `init-gitignore`.
2. CrÃ©ez le fichier `.gitignore` Ã  la racine du dÃ©pÃ´t.
3. Ajoutez-y la ligne `bin/assert/` afin d'ignorer le dossier `bin/assert` et tout son contenu. 
4. Ajoutez le fichier `.gitignore` Ã  l'index : `git add .gitignore`.
5. VÃ©rifiez l'Ã©tat des fichiers locaux avec `git status`.
- Si le fichier `bin/assert/01-env` est listÃ©, c'est qu'il a Ã©tÃ© ajoutÃ© par erreur.
<br>Supprimez-le de l'index avec `git restore --staged bin/assert/01-env`. 
- Normalement, il ne devrait y avoir que le fichier `.gitignore` listÃ©.
6. Commitez le fichier : `git commit -m "ğŸ™ˆ Initial commit"`.
7. Pushez la branche sur le dÃ©pÃ´t distant : `git push origin init-gitignore`.
8. Sur GitHub, crÃ©ez la PR pour merger la branche `init-gitignore` sur la branche `main`.
9. Le reste du groupe peut faire la revue de la PR et une fois approuvÃ©e, la merger.

## ğŸ§¹ Remise Ã  niveau

VÃ©rifiez bien que la branche `init-gitignore` a Ã©tÃ© supprimÃ©e du GitHub aprÃ¨s la PR.

Ensuite, il faut synchroniser le repository local.

### Pour la personne ayant fait la MR

```bash
git switch main
git pull
git branch -D init-gitignore
```

### Pour les autres personnes

```bash
git switch main
git pull
```

# 2. README.md

Le fichier `README` est le "point d'entrÃ©e" d'un repository ; il est affichÃ© sur la page principale du repository sur 
GitHub ou GitLab et est gÃ©nÃ©ralement le fichier ouvert par dÃ©faut dans l'IDE.

Ce fichier dÃ©crit le projet, son but, son fonctionnement et les diverses instructions pour le mettre en place ou 
l'utiliser.

Dans le cadre de ce TP, il servira Ã  dÃ©crire le TP, les contributeurs (membres du groupe), les tÃ¢ches (et si elles ont 
Ã©tÃ© rÃ©alisÃ©es), ainsi que vos retours d'expÃ©rience.

## ğŸ“‹ï¸ Instructions

1. CrÃ©ez la branche `init-readme`.
2. CrÃ©ez le fichier `README.md` Ã  la racine du dÃ©pÃ´t, s'il n'a pas dÃ©jÃ  Ã©tÃ© initialisÃ© sur GitHub.
3. RÃ©cupÃ©rez le contenu dÃ©fini ci-dessous en le remplissant avec les informations demandÃ©es.
4. VÃ©rifiez qu'il ne reste aucun commentaire ou instruction dans le fichier.
5. Ajoutez le fichier `README.md` Ã  l'index : `git add README.md`.
6. Commitez le fichier : `git commit -m "ğŸ‘“ï¸ Initial commit"`.
7. Pushez la branche sur le dÃ©pÃ´t distant et crÃ©ez la PR correspondante.
8. Pensez Ã  la revue, Ã  l'approbation, au merge, puis Ã  la Â« ğŸ§¹ remise Ã  niveau Â», telle qu'elle Ã©tait prÃ©sentÃ©e 
dans la tÃ¢che prÃ©cÃ©dente.

### ğŸ“ Contenu du README.md

RÃ©cupÃ©rez le contenu suivant en le remplissant avec les informations demandÃ©es.

> **Note** : Ce qui est indiquÃ© entre chevrons doit Ãªtre intÃ©gralement remplacÃ© par la valeur demandÃ©e.
> <br>Par exemple, `<NOM PrÃ©nom>` sera remplacÃ© par `VILLENA Billy`, dans mon cas.
> <br><br>
> **NoteÂ²** : Les lignes indiquÃ©es de cette maniÃ¨re : `[//]: # (texte)` font office de commentaires. Ce sont des
> instructions ou des remarques pour vous aider Ã  remplir le contenu du fichier.
> <br>Elles ne doivent pas Ãªtre prÃ©sentes dans le fichier final.

```markdown
# 3OLEN "Lumos Camminus" - <Nom du groupe> - TP Git 1

[//]: # (Courte description du TP)

## ğŸ¯ Objectifs

[//]: # (Liste des objectifs dÃ©finis sur la page du cours.)
[//]: # (Veuillez Ã  bien utiliser la syntaxe de liste Markdown ainsi que les diffÃ©rentes rÃ¨gles de formatage)

## ğŸ“šï¸ Ressources utiles

- [ğŸ”— Sujet de TP](https://3olen.github.io/cours-initiaux/git/tp/1)
- [ğŸ”— Cours 8 dÃ©cembre](https://3olen.github.io/git/8-decembre)
[//]: # (Ã‰ventuellement d'autres liens ou ressources utiles pour la rÃ©alisation de ce TP si vous en avez l'utilitÃ©)

## ğŸ‘¥ Contributeurs

[//]: # (Pour chaque Ã©tudiant du groupe âš ï¸ dans l'ordre alphabÃ©tique des noms de famille :)
- [<NOM PrÃ©nom>](<Lien vers le profil GitHub>)
[//]: # "Faites attention Ã  bien garder la syntaxe des liens : `[texte affichÃ©](lien hypertexte)`"

## ğŸ“‹ï¸ Instructions du projet

*Rien pour l'instant...*
[//]: # (Tout ce qui permettra de mettre en place le projet en local sera indiquÃ© ici)

## ğŸ“ TÃ¢ches

- [x] **.gitignore** : Initialisation du `.gitignore`.
- [x] **README.md** : Initialisation du `README.md`.
- [ ] **.editorconfig** : Initialisation du `.editorconfig`.
- [ ] **Hooks** : N'autoriser qu'un commit par branche.
[//]: # (En prenant exemple sur les deux premiÃ¨res lignes de la liste, faites de mÃªme pour les autres tÃ¢ches)
[//]: # (La syntaxe `- [ ]` permet de dÃ©finir une liste Ã  cocher ; parfait pour un todo-list)
[//]: # (La syntaxe `- [x]` permet de cocher la case et donc dÃ©finir la tÃ¢che comme terminÃ©e)

## ğŸ•â€ğŸ¦º Retours d'expÃ©rience

### <NOM PrÃ©nom du contributeur 1>

*__TODO__: Retours d'expÃ©rience de l'Ã©tudiant.*

[//]: # (Faire de mÃªme pour chaque membre du groupe)
```

# 3. .editorconfig

Afin de contribuer Ã  l'homogÃ©nÃ©itÃ© des fichiers textes, les IDE et certains Ã©diteurs de texte (par le biais de plugins)
prennent en charge les spÃ©cifications `EditorConfig` par le biais du fichier `.editorconfig`.

On y trouve des rÃ¨gles de formatage basiques : indentation, encodage, taille et fin de ligne, etc.

Il s'agit d'un trÃ¨s bon ajout Ã  notre TP et pour n'importe quel projet.

Pour en savoir plus : [ğŸ”— EditorConfig](https://editorconfig.org/).

## ğŸ“‹ï¸ Instructions

1. CrÃ©ez la branche `init-editorconfig`.
2. CrÃ©ez le fichier `.editorconfig` Ã  la racine du dÃ©pÃ´t.
3. Ajoutez le contenu dÃ©fini ci-aprÃ¨s dans le fichier.
4. Ajoutez le fichier `.editorconfig` Ã  l'index : `git add .editorconfig`.
5. Modifiez le `README.md` pour cocher la tÃ¢che correspondante, puis ajoutez ce fichier Ã  l'index.
6. Commitez les changements : `git commit -m "ğŸ Initial commit"`.
7. Pushez la branche sur le dÃ©pÃ´t distant et crÃ©ez la PR correspondante.
8. Pensez Ã  la revue, Ã  l'approbation, au merge, puis Ã  la Â« ğŸ§¹ remise Ã  niveau Â».

### ğŸ“ Contenu du .editorconfig

```ini
root = true

[*]
charset = utf-8
end_of_line = lf
indent_size = 4
indent_style = space
insert_final_newline = true
tab_width = 4
trim_trailing_whitespace = true

[*.md]
max_line_length = 120
```

# 4. Hooks

Les *hooks* sont des scripts exÃ©cutÃ©s par Git lors de certains Ã©vÃ©nements (avant un commit par exemple). Ils permettent
d'automatiser des tÃ¢ches et de vÃ©rifier la qualitÃ© du travail avant de le commiter.

> **Point de vue personnel**<br>
> Utilisez des hooks pour vÃ©rifier seulement, et rejeter l'action si les conditions ne sont pas remplies.
> <br>
> Ne les utilisez pas pour rÃ©aliser des actions automatiques sur le travail rÃ©alisÃ© (formatage de code par exemple).
> C'est Ã  chaque membre de l'Ã©quipe de prendre la responsabilitÃ© de son travail et de le faire correctement. Et c'est Ã 
> chacun de "s'Ã©duquer" sur les rÃ¨gles mises en place Ã  respecter.
> <br>
> Par ailleurs, vous pourriez avoir des surprises avec des modifications automatiques d'un script ou d'un linter.

Nous allons mettre en place un hook qui va vÃ©rifier que la branche locale ne dÃ©finit qu'un seul commit.

Dans les bonnes pratiques des branches, il n'est jamais nÃ©cessaire de dÃ©finir plusieurs commits sur une mÃªme branche,
puisque chaque branche doit reprÃ©senter une tÃ¢che aussi petite et Ã©purÃ©e que possible. Si ce n'est pas le cas, c'est que
la branche (et sa tÃ¢che associÃ©e) n'a sÃ»rement pas Ã©tÃ© correctement dÃ©coupÃ©e.

## ğŸ“‹ï¸ Instructions

{% assign resource_script_hook_pre_commit = site.static_files | where: "name", "hook-pre-commit-01" | first %}

1. CrÃ©ez la branche `init-hooks`.
2. CrÃ©ez le dossier `bin/hooks` depuis la racine du repository.
3. RÃ©cupÃ©rez le fichier : [hook-pre-commit-01]({{ resource_script_hook_pre_commit.path | relative_url }}).
4. DÃ©placez-le dans le dossier `bin/hooks` de votre dÃ©pÃ´t et renommez-le `pre-commit`.
5. Assurez-vous qu'il est bien exÃ©cutable avec les commandes appropriÃ©es.
6. Copiez-le dans le dossier `.git/hooks` de votre repository.
<br>C'est de cette maniÃ¨re que votre Git local va pouvoir le prendre en considÃ©ration et l'exÃ©cuter.
7. Ajoutez le fichier `bin/hooks/pre-commit` Ã  l'index et commitez-le : 
`git commit -m "ğŸ”¨ [hooks] One commit per branch"`.
<br>Normalement, le hook a Ã©tÃ© exÃ©cutÃ© et le commit a Ã©tÃ© acceptÃ©.
8. Modifiez le `README.md` pour cocher la tÃ¢che correspondante, puis ajoutez ce fichier Ã  l'index.
9. Tentez d'effectuer un nouveau commit : `git commit -m "ğŸ‘“ï¸ [Hooks] done"`.
<br>Normalement, le hook a Ã©tÃ© exÃ©cutÃ© et le commit a Ã©tÃ© rejetÃ© : `Vous avez dÃ©jÃ  un commit dÃ©fini [...]`.
10. Amendez donc le commit prÃ©cÃ©dent, sans modifier le message : `git commit --amend --no-edit`.
<br>Cette fois, le commit a Ã©tÃ© acceptÃ©.

Pour mener cette vÃ©rification jusqu'au bout, on peut faire un hook avant le push.

{% assign resource_script_hook_pre_push = site.static_files | where: "name", "hook-pre-push-01" | first %}
1. RÃ©cupÃ©rez le fichier : [hook-pre-push-01]({{ resource_script_hook_pre_push.path | relative_url }}).
2. DÃ©placez-le dans le dossier `bin/hooks` de votre dÃ©pÃ´t et renommez-le `pre-push`.
3. Assurez-vous qu'il est bien exÃ©cutable avec les commandes appropriÃ©es.
4. Copiez-le dans le dossier `.git/hooks` de votre repository.
5. Ajoutez le fichier `bin/hooks/pre-push` Ã  l'index et commitez-le :
`git commit --no-verify -m "ğŸ”¨ [hooks] Do not push several commits"`.
<br>L'option `--no-verify` permet de *by-passer* l'exÃ©cution du pre-commit hook.
6. Tentez de pusher la branche avec ses deux commits.
<br>Normalement, le hook a Ã©tÃ© exÃ©cutÃ© et le push a Ã©tÃ© rejetÃ© : `Vous avez plusieurs commits. [...]`.
7. ExÃ©cutez alors le rebase interactif comme demandÃ© : `git rebase -i HEAD~2`.
  - Dans l'Ã©diteur de texte fourni, remplacez le mot-clÃ© `pick` par `squash` (ou `s`) pour le second commit.
  - Sauvegardez et fermez l'Ã©diteur (si Ã©diteur de base : `Ctrl + x`, puis `o` et enfin `EntrÃ©e`).
  - L'Ã©diteur de texte s'ouvre Ã  nouveau pour dÃ©finir le nouveau message de commit. Gardez le message du premier commit.
8. Faites de nouveau un push qui devrait Ãªtre acceptÃ© et effectif.
9. Vous connaissez la chanson : PR / revue / approbation / Merge / ğŸ§¹ remise Ã  niveau.

# Et maintenant ?

Vous avez pu manipuler la majoritÃ© des Ã©lÃ©ments de base d'un projet Git tout en effectuant quelques commits et pushs.

Nous en avons profitÃ© pour rappeler quelques outils avancÃ©s utilisÃ©s pour garantir un historique "lÃ©ger" : le
`commit --amend` et le *squash* par le biais du rebase interactif.

Et vous avez dÃ©couvert les hooks et une possible utilisation. Il y a cependant quelque chose d'incomplet avec ces
hooks ; on les a versionnÃ©s dans le dossier `bin/hooks`, mais ils ne sont pas pris en compte par Git. Il faut les
copier dans le dossier `.git/hooks`.

Comment garantir que chaque membre du groupe a installÃ© les hooks ? Et comment garantir que les hooks sont toujours
maintenus Ã  jour dans chaque environnement local ?

C'est le sujet de la partie suivante !
